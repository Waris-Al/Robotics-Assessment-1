{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\ndef main():\n    '''\n    This code employs a wall following algorithm to solve the maze, and then trace its way back marking the right path\n    It traverses the maze, saving the headings it needs to take to go to the end. Any incorrect headings are forgotten once realised.\n    It then goes backwards through these headings to map the route out and go back to the start.\n    '''\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n    #Lists to store the coordinates and headings\n    coordinatesList = []\n    headingsList = []\n\n    #Wall following algorithm\n    #Bot will go forward 250MM, check if it can go right,  or continue straight ahead. If it can't go straight or right, it turns to its left.\n    #This is repeated until the exit is found\n    while not down_eye.detect(RED):\n\n        if front_distance.get_distance(MM) > 250:\n            drivetrain.drive_for(FORWARD, 250, MM)\n\n            '''\n            We work out our current coordiantes, and the heading used to get there. If we've visited these coordinates before, we've been down the wrong path and can forget that route.\n            We have to round the values due to the robot moving a few MM sometimes. This leads to visited points not being seen as visited (due to a less than 2MM difference)\n            which will lead to an incorrect route back\n            '''\n            xLocation = str(round(location.position(X, MM) / 10) * 10)\n            yLocation = str(round(location.position(Y, MM) / 10) * 10)\n\n            currentCoordinates = xLocation + \" , \" + yLocation\n            if currentCoordinates in coordinatesList:\n                coordinatesList.remove(currentCoordinates)\n                headingsList.pop()\n            else:\n                coordinatesList.append(currentCoordinates)\n                headingsList.append(drivetrain.heading(DEGREES))\n            \n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n        else:\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n\n\n    #We go backwards through the list, turning to the opposite heading of what was noted, to retrace our way back to the start\n    pen.set_pen_color(BLUE)\n    pen.move(DOWN)\n    for direction in reversed(headingsList):\n        if direction > 0:\n            reversedHeading = direction - 180\n        else:\n            reversedHeading = direction + 180\n\n        drivetrain.turn_to_heading(reversedHeading, DEGREES)\n        drivetrain.drive_for(FORWARD, 250, MM)\n        \n\n# VR threads â€” Do not delete\nvr_thread(main)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}