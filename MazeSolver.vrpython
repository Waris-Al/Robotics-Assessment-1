{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\ndef main():\n    '''\n    This code employs a wall following algorithm to solve the maze, and then trace its way back marking the right path\n    It traverses the maze, saving the coordinates/headings it needs to take to go to the end. Any incorrect coordinates/headings are forgotten once realised.\n    It then goes backwards through these coordinates/headings to map the route out and go back to the start.\n    '''\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    squaresExplored = 0\n\n    routeTaken = {} #Store the coordinates and headings in a dictionary\n\n    '''Wall following algorithm:\n    Bot will go forward 250MM, check if it can go right,  or continue straight ahead. If it can't go straight or right, it turns to its left.\n    This is repeated until the exit is found'''\n    while True: #figure out how to write this so that it breaks when squares is 64\n\n        if squaresExplored > 60:\n            break\n\n        while not down_eye.detect(RED):\n            xLocation = round(location.position(X, MM) / 10) * 10\n            yLocation = round(location.position(Y, MM) / 10) * 10\n            currentCoordinates = (xLocation, yLocation)  # Now an integer tuple!\n\n            #brain.print(currentCoordinates)\n            #brain.new_line()\n\n            if (yLocation == -900 or yLocation == -890) and xLocation == 130 and squaresExplored > 60:\n                drivetrain.turn_to_heading(0, DEGREES)\n                break\n\n            if (yLocation == -900 or yLocation == -890) and xLocation == 130 and drivetrain.heading(DEGREES) == 180: #Edge Case handling: When starting blocked on the left and front\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n\n            if front_distance.get_distance(MM) > 250:\n                drivetrain.drive_for(FORWARD, 250, MM)\n\n                #Edge Case Handling: Robot will glitch at certain Y coordinates\n                if (-645 <= location.position(Y, MM) <= -635) or (-393 <= location.position(Y, MM) <= -387):\n                    yLocation = str(location.position(Y, MM) - 10)\n                \n\n                #Check if coordinates have been visited. Remove them from the dictionary if needed. Otherwise add them. Coordinates used as key.\n                if currentCoordinates not in routeTaken:\n                    originalHeading = drivetrain.heading(DEGREES)\n                    walls = {(115, 0): {\"inFront\": True, \"behind\": False, \"right\": True, \"left\": False}}\n                    for i in range(4):\n                        if front_distance.get_distance(MM) < 250:\n                            currentHeading = drivetrain.heading(DEGREES)\n                            if currentHeading == 0:\n                                walls['inFront'] = True\n                            elif currentHeading == 90:\n                                walls['right'] = True\n                            elif currentHeading == 180:\n                                walls['behind'] = True\n                            elif currentHeading == 270:\n                                walls['left'] = True\n                            \n                        drivetrain.turn_for(RIGHT, 90, DEGREES)\n                    \n                    drivetrain.turn_to_heading(originalHeading, DEGREES)\n\n                    routeTaken[currentCoordinates] = walls\n                    squaresExplored = squaresExplored + 1\n                \n                drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n            else:\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n\n        if down_eye.detect(RED):\n            drivetrain.turn_for(LEFT, 270, DEGREES)\n            drivetrain.drive_for(FORWARD, 250, MM)\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n      \n    brain.print(routeTaken)\n\n# VR threads â€” Do not delete\nvr_thread(main)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}