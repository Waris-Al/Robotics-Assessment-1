{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\ndef main():\n    '''\n    This code employs a wall following algorithm to solve the maze, and then trace its way back marking the right path\n    It traverses the maze, saving the coordinates/headings it needs to take to go to the end. Any incorrect coordinates/headings are forgotten once realised.\n    It then goes backwards through these coordinates/headings to map the route out and go back to the start.\n    '''\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n    routeTaken = {} #Store the coordinates and headings in a dictionary\n\n    '''Wall following algorithm:\n    Bot will go forward 250MM, check if it can go right,  or continue straight ahead. If it can't go straight or right, it turns to its left.\n    This is repeated until the exit is found'''\n    while not down_eye.detect(RED):\n\n        if location.position(Y, MM) == -900 and location.position(X, MM) == 130 and drivetrain.heading(DEGREES) == 180: #Edge Case handling: When starting blocked on the left and front\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n\n        if front_distance.get_distance(MM) > 250:\n            drivetrain.drive_for(FORWARD, 250, MM)\n\n            yCoordinate = location.position(Y, MM) #Edge Case Handling: Robot will glitch at certain Y coordinates\n            if (-645 <= location.position(Y, MM) <= -635) or (-393 <= location.position(Y, MM) <= -387):\n                yCoordinate = location.position(Y, MM) - 10\n            xLocation = str(round(location.position(X, MM) / 10) * 10)\n            yLocation = str(round(yCoordinate / 10) * 10)\n            currentCoordinates = xLocation + \" , \" + yLocation\n\n            #Check if coordinates have been visited. Remove them from the dictionary if needed. Otherwise add them. Coordinates used as key.\n            if currentCoordinates in routeTaken:\n                routeTaken.popitem() \n            else:\n                routeTaken[currentCoordinates] = drivetrain.heading(DEGREES)\n            \n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n        else:\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n\n    brain.print(routeTaken)\n    #We go backwards through the list, turning to the opposite heading of what was noted, to retrace our way back to the start\n    pen.set_pen_color(BLUE)\n    pen.move(DOWN)\n    \n    reversedDirections = dict(reversed(list(routeTaken.items())))\n    for coordinates, direction in reversedDirections.items():\n        if direction > 0:\n            reversedHeading = direction - 180\n        else:\n            reversedHeading = direction + 180\n\n        drivetrain.turn_to_heading(reversedHeading, DEGREES)\n        drivetrain.drive_for(FORWARD, 250, MM)\n        \n\n# VR threads â€” Do not delete\nvr_thread(main)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}