{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\nfrom collections import deque\n\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\ndef main():\n    '''\n    This code employs a wall following algorithm to solve the maze, and then trace its way back marking the right path\n    It traverses the maze, saving the coordinates/headings it needs to take to go to the end. Any incorrect coordinates/headings are forgotten once realised.\n    It then goes backwards through these coordinates/headings to map the route out and go back to the start.\n    '''\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    squaresExplored = 0\n\n    routeTaken = {} #Store the coordinates and headings in a dictionary\n    '''Wall following algorithm:\n    Bot will go forward 250MM, check if it can go right,  or continue straight ahead. If it can't go straight or right, it turns to its left.\n    This is repeated until the exit is found'''\n    while True: #figure out how to write this so that it breaks when squares is 64\n\n        if squaresExplored > 60:\n            break\n\n        while not down_eye.detect(RED):\n            xLocation = round(location.position(X, MM) / 10) * 10\n            yLocation = round(location.position(Y, MM) / 10) * 10\n\n            #brain.print(currentCoordinates)\n            #brain.new_line()\n\n            if (yLocation == -900 or yLocation == -890) and xLocation == 130 and squaresExplored > 60:\n                drivetrain.turn_to_heading(0, DEGREES)\n                break\n\n            if (yLocation == -900 or yLocation == -890) and xLocation == 130 and drivetrain.heading(DEGREES) == 180: #Edge Case handling: When starting blocked on the left and front\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n\n            if front_distance.get_distance(MM) > 250:\n                drivetrain.drive_for(FORWARD, 250, MM)\n\n                xLocation = round(location.position(X, MM) / 10) * 10\n                yLocation = round(location.position(Y, MM) / 10) * 10\n                currentCoordinates = (xLocation, yLocation) \n\n                #Edge Case Handling: Robot will glitch at certain Y coordinates\n                if (-645 <= location.position(Y, MM) <= -635) or (-393 <= location.position(Y, MM) <= -387):\n                    yLocation = str(location.position(Y, MM) - 10)\n                \n\n                #Check if coordinates have been visited. Add unvisited ones. Coordinates used as key.\n                if currentCoordinates not in routeTaken:\n                    originalHeading = drivetrain.heading(DEGREES)\n                    walls = {\"inFront\": False, \"behind\": False, \"right\": False, \"left\": False}\n                    for i in range(4):\n                        if front_distance.get_distance(MM) <= 250:\n                            currentHeading = drivetrain.heading(DEGREES)\n                            if currentHeading == 0:\n                                walls['inFront'] = True\n                            elif currentHeading == 90:\n                                walls['right'] = True\n                            elif currentHeading == 180:\n                                walls['behind'] = True\n                            elif currentHeading == 270:\n                                walls['left'] = True\n                            \n                        drivetrain.turn_for(RIGHT, 90, DEGREES)\n                    \n                    drivetrain.turn_to_heading(originalHeading, DEGREES)\n\n                    routeTaken[currentCoordinates] = walls\n                    squaresExplored = squaresExplored + 1\n                \n                drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n            else:\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n\n        if down_eye.detect(RED):\n            walls = {\"inFront\": False, \"behind\": False, \"right\": False, \"left\": False}\n            for i in range(4):\n                if front_distance.get_distance(MM) < 250:\n                    currentHeading = drivetrain.heading(DEGREES)\n                    if currentHeading == 0:\n                        walls['inFront'] = True\n                    elif currentHeading == 90:\n                        walls['right'] = True\n                    elif currentHeading == 180:\n                        walls['behind'] = True\n                    elif currentHeading == 270:\n                        walls['left'] = True\n                                                            \n                drivetrain.turn_for(RIGHT, 90, DEGREES)\n            drivetrain.turn_for(LEFT, 270, DEGREES)\n            drivetrain.drive_for(FORWARD, 250, MM)\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n      \n    #Graph\n    graph = {}\n\n    for position, data in routeTaken.items():\n        x, y = position  \n        walls = data \n        neighbors = []\n\n        possible_neighbors = [\n            ((x, y + 250), 'inFront'), \n            ((x, y - 250), 'behind'),  \n            ((x + 250, y), 'right'),   \n            ((x - 250, y), 'left'),   \n        ]\n        \n        for neighbor, direction in possible_neighbors:\n            if neighbor in routeTaken and not walls.get(direction, True): \n                neighbors.append(neighbor)\n\n        if not neighbors:\n            print(f\"Warning: {position} has no neighbors\")\n\n        if neighbors:\n            graph[position] = neighbors\n\n\n    startOfMaze = (130, -890)\n    endOfMaze = (-120, 860)\n\n    startToEnd = bfs(startOfMaze, endOfMaze, graph)\n    returnHome = bfs(endOfMaze, startOfMaze, graph)\n\n    brain.print(routeTaken)\n    brain.new_line()\n    brain.print(\"Shortest Path:\", startToEnd)\n\n    followPath(startToEnd)\n    drivetrain.turn_for(RIGHT, 180, DEGREES)\n    followPath(returnHome)\n\n\n\ndef bfs(startOfMaze, endOfMaze, graph):\n    queue = deque([(startOfMaze, [])])\n    visited = set()\n\n    while queue:\n        current, path = queue.popleft()\n\n        if current == endOfMaze:\n            return path + [current]\n\n        if current in visited:\n            continue\n\n        visited.add(current)\n\n        for neighbor in graph.get(current, []):\n            if neighbor not in visited:\n                queue.append((neighbor, path + [current]))\n\n    return None\n\ndef followPath(shortestPath):\n    pen.set_pen_color(BLUE)\n    pen.move(DOWN)\n    for i in range(len(shortestPath) - 1):\n        currentPoint = shortestPath[i]\n        nextPoint = shortestPath[i+1]\n\n        currentX, currentY = currentPoint\n        nextX, nextY = nextPoint\n\n        if currentX == nextX:\n            if currentY > nextY:\n                drivetrain.turn_to_heading(180, DEGREES)\n                drivetrain.drive_for(FORWARD, 250, MM)\n            else:\n                drivetrain.turn_to_heading(0, DEGREES)\n                drivetrain.drive_for(FORWARD, 250, MM)\n        \n        elif currentY == nextY:\n            if currentX > nextX:\n                drivetrain.turn_to_heading(270, DEGREES)\n                drivetrain.drive_for(FORWARD, 250, MM)\n            else:\n                drivetrain.turn_to_heading(90, DEGREES)\n                drivetrain.drive_for(FORWARD, 250, MM)\n\n# VR threads â€” Do not delete\nvr_thread(main)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}